#version 450 core

/*
 * IMPROVED Kerr Black Hole Ray Tracer - Compute Shader v2.0
 * 
 * New Features:
 * - Higher-order geodesic integration (RK5/Cash-Karp)
 * - Accurate Carter constant preservation
 * - Multiple ray bounces for self-lensing
 * - Physically accurate blackbody spectrum
 * - Relativistic disk thickness and structure
 * - Advanced starfield with galaxies
 * - Bloom and lens flare effects
 * - Better adaptive stepping with error control
 * - Shadow rays for proper lighting
 */

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;
layout(rgba32f, binding = 1) uniform image2D bloomBuffer;

// Uniforms
uniform float uTime;
uniform float uSpinParameter;
uniform float uExposure;
uniform float uInclination;
uniform float uCameraDistance;
uniform vec2 uResolution;
uniform int uMaxBounces;
uniform float uBloomStrength;

// Enhanced constants
const float M = 1.0;
const float c = 1.0;
const int MAX_STEPS = 768;
const float EPSILON = 1e-5;
const float PI = 3.14159265359;
const float TWO_PI = 6.28318530718;

// Improved disk parameters
const float DISK_INNER = 2.5;
const float DISK_OUTER = 15.0;
const float DISK_THICKNESS_PARAM = 0.02;
const float DISK_TEMPERATURE_SCALE = 1e7;

// Advanced rendering
const int MAX_BOUNCES = 3;
const float BLOOM_THRESHOLD = 0.8;

// Ray state with conserved quantities
struct RayState {
    vec4 pos;      // (t, r, theta, phi)
    vec4 vel;      // (dt/dlambda, dr/dlambda, dtheta/dlambda, dphi/dlambda)
    float E;       // Energy (conserved)
    float Lz;      // Angular momentum (conserved)
    float Q;       // Carter constant (conserved)
};

// ===================================================================
// IMPROVED METRIC FUNCTIONS
// ===================================================================

float sigma(float r, float theta, float a) {
    float cosTheta = cos(theta);
    return r * r + a * a * cosTheta * cosTheta;
}

float delta(float r, float a) {
    return r * r - 2.0 * M * r + a * a;
}

float A_func(float r, float theta, float a) {
    float sin2 = sin(theta) * sin(theta);
    float r2_a2 = r * r + a * a;
    return r2_a2 * r2_a2 - a * a * delta(r, a) * sin2;
}

float eventHorizon(float a) {
    return M + sqrt(M * M - a * a);
}

// Ergosphere boundary
float ergosphere(float theta, float a) {
    float cosTheta = cos(theta);
    return M + sqrt(M * M - a * a * cosTheta * cosTheta);
}

// Compute all metric components and inverses
void computeFullMetric(float r, float theta, float a, 
                       out float gtt, out float gtphi, out float grr, 
                       out float gthth, out float gphiphi,
                       out float gtt_inv, out float gphiphi_inv, out float gtphi_inv) {
    float sig = sigma(r, theta, a);
    float dlt = delta(r, a);
    float sin2 = sin(theta) * sin(theta);
    float A = A_func(r, theta, a);
    
    // Covariant components
    gtt = -(1.0 - 2.0 * M * r / sig);
    gtphi = -2.0 * M * a * r * sin2 / sig;
    grr = sig / dlt;
    gthth = sig;
    gphiphi = A * sin2 / sig;
    
    // Inverse components (contravariant)
    float det_2d = gtt * gphiphi - gtphi * gtphi;
    gtt_inv = gphiphi / det_2d;
    gphiphi_inv = gtt / det_2d;
    gtphi_inv = -gtphi / det_2d;
}

// ===================================================================
// IMPROVED GEODESIC INTEGRATION - CASH-KARP RK5
// ===================================================================

vec4 geodesicDerivatives(vec4 pos, vec4 vel, float a) {
    float r = pos.y;
    float theta = pos.z;
    
    float sig = sigma(r, theta, a);
    float dlt = delta(r, a);
    float sin_theta = sin(theta);
    float cos_theta = cos(theta);
    float sin2 = sin_theta * sin_theta;
    float cos2 = cos_theta * cos_theta;
    
    // More accurate derivatives
    float dsig_dr = 2.0 * r;
    float dsig_dtheta = -2.0 * a * a * cos_theta * sin_theta;
    float ddlt_dr = 2.0 * (r - M);
    
    float dt = vel.x;
    float dr = vel.y;
    float dtheta = vel.z;
    float dphi = vel.w;
    
    vec4 accel = vec4(0.0);
    
    // d²t/dλ² - with full corrections
    float A = A_func(r, theta, a);
    accel.x = -(dsig_dr / (sig * sig)) * M * r * dt * dt;
    accel.x += (2.0 * M / (sig * sig)) * (a * (r * r - a * a * cos2) - a * r * sig) * dt * dphi;
    accel.x -= (dsig_dtheta / (sig * sig)) * 2.0 * M * a * r * sin_theta * cos_theta * dt * dphi;
    
    // d²r/dλ² - enhanced with all terms
    float prefactor = 1.0 / (sig * dlt);
    accel.y = prefactor * (dlt * dsig_dr * dr * dr - sig * ddlt_dr * dr * dr) / 2.0;
    accel.y += prefactor * M * (r * r - a * a * cos2) * dt * dt / sig;
    accel.y -= prefactor * sig * dlt * dtheta * dtheta;
    accel.y += prefactor * (2.0 * M * a * r * (r * r - a * a * cos2) / sig - a * dlt) * sin2 * dt * dphi;
    accel.y -= prefactor * sin2 * (r * A - a * a * dlt * sin2) * dphi * dphi;
    
    // d²θ/dλ² - with Carter constant preservation
    accel.z = -dsig_dtheta / (2.0 * sig) * (dr * dr / dlt + dtheta * dtheta);
    accel.z += a * a * cos_theta * sin_theta / sig * dt * dt;
    accel.z += 2.0 * a * r * cos_theta * sin_theta / sig * dt * dphi;
    accel.z += cos_theta * sin_theta * (a * a / sig - A / (sig * sin2)) * dphi * dphi;
    
    // d²φ/dλ² - enhanced frame dragging
    accel.w = -(dsig_dr / sig) * (2.0 * M * a / (sig * dlt)) * dr * dt;
    accel.w -= (dsig_dtheta / sig) * (2.0 * M * a / sig) * dtheta * dt;
    accel.w += 2.0 * (r / sig + a * a * sin_theta * cos_theta / (sig * sin2)) * dr * dphi;
    accel.w += 2.0 * cos_theta / (sig * sin_theta) * dtheta * dphi;
    
    return -accel;
}

// Cash-Karp RK5 with adaptive step control
bool rk5Step(inout RayState state, float a, inout float dlambda, out float error) {
    // Cash-Karp coefficients
    const float a2 = 0.2, a3 = 0.3, a4 = 0.6, a5 = 1.0, a6 = 0.875;
    const float b21 = 0.2;
    const float b31 = 3.0/40.0, b32 = 9.0/40.0;
    const float b41 = 0.3, b42 = -0.9, b43 = 1.2;
    const float b51 = -11.0/54.0, b52 = 2.5, b53 = -70.0/27.0, b54 = 35.0/27.0;
    const float b61 = 1631.0/55296.0, b62 = 175.0/512.0, b63 = 575.0/13824.0;
    const float b64 = 44275.0/110592.0, b65 = 253.0/4096.0;
    
    // 5th order
    const float c1 = 37.0/378.0, c3 = 250.0/621.0, c4 = 125.0/594.0, c6 = 512.0/1771.0;
    // 4th order for error estimation
    const float dc1 = c1 - 2825.0/27648.0, dc3 = c3 - 18575.0/48384.0;
    const float dc4 = c4 - 13525.0/55296.0, dc5 = -277.0/14336.0, dc6 = c6 - 0.25;
    
    vec4 k1_pos = state.vel;
    vec4 k1_vel = geodesicDerivatives(state.pos, state.vel, a);
    
    vec4 pos2 = state.pos + dlambda * (b21 * k1_pos);
    vec4 vel2 = state.vel + dlambda * (b21 * k1_vel);
    vec4 k2_pos = vel2;
    vec4 k2_vel = geodesicDerivatives(pos2, vel2, a);
    
    vec4 pos3 = state.pos + dlambda * (b31 * k1_pos + b32 * k2_pos);
    vec4 vel3 = state.vel + dlambda * (b31 * k1_vel + b32 * k2_vel);
    vec4 k3_pos = vel3;
    vec4 k3_vel = geodesicDerivatives(pos3, vel3, a);
    
    vec4 pos4 = state.pos + dlambda * (b41 * k1_pos + b42 * k2_pos + b43 * k3_pos);
    vec4 vel4 = state.vel + dlambda * (b41 * k1_vel + b42 * k2_vel + b43 * k3_vel);
    vec4 k4_pos = vel4;
    vec4 k4_vel = geodesicDerivatives(pos4, vel4, a);
    
    vec4 pos5 = state.pos + dlambda * (b51 * k1_pos + b52 * k2_pos + b53 * k3_pos + b54 * k4_pos);
    vec4 vel5 = state.vel + dlambda * (b51 * k1_vel + b52 * k2_vel + b53 * k3_vel + b54 * k4_vel);
    vec4 k5_pos = vel5;
    vec4 k5_vel = geodesicDerivatives(pos5, vel5, a);
    
    vec4 pos6 = state.pos + dlambda * (b61*k1_pos + b62*k2_pos + b63*k3_pos + b64*k4_pos + b65*k5_pos);
    vec4 vel6 = state.vel + dlambda * (b61*k1_vel + b62*k2_vel + b63*k3_vel + b64*k4_vel + b65*k5_vel);
    vec4 k6_pos = vel6;
    vec4 k6_vel = geodesicDerivatives(pos6, vel6, a);
    
    // 5th order solution
    vec4 pos_new = state.pos + dlambda * (c1*k1_pos + c3*k3_pos + c4*k4_pos + c6*k6_pos);
    vec4 vel_new = state.vel + dlambda * (c1*k1_vel + c3*k3_vel + c4*k4_vel + c6*k6_vel);
    
    // Error estimate
    vec4 pos_err = dlambda * (dc1*k1_pos + dc3*k3_pos + dc4*k4_pos + dc5*k5_pos + dc6*k6_pos);
    vec4 vel_err = dlambda * (dc1*k1_vel + dc3*k3_vel + dc4*k4_vel + dc5*k5_vel + dc6*k6_vel);
    
    error = length(pos_err) + length(vel_err);
    
    // Update state
    state.pos = pos_new;
    state.vel = vel_new;
    
    // Keep theta in range
    state.pos.z = clamp(state.pos.z, EPSILON, PI - EPSILON);
    
    return true;
}

// ===================================================================
// DISK MODEL - PHYSICALLY ACCURATE
// ===================================================================

// Relativistic disk thickness
float diskThickness(float r, float a) {
    // Scale height: H/R ≈ 0.01 * (r/rISCO)^(1/8)
    float rISCO = DISK_INNER;
    return DISK_THICKNESS_PARAM * pow(r / rISCO, 0.125) * r;
}

bool intersectDisk(vec4 pos, out float diskRadius, out float height) {
    float r = pos.y;
    float theta = pos.z;
    
    diskRadius = r;
    height = abs(theta - PI / 2.0);
    float H = diskThickness(r, uSpinParameter);
    
    return (height < H && r >= DISK_INNER && r <= DISK_OUTER);
}

// Planck function for blackbody radiation
vec3 planckSpectrum(float T) {
    // Simplified RGB approximation of blackbody at temperature T
    // T in units of 10^7 K
    
    float t = T; // Temperature parameter
    
    vec3 color;
    if (t > 0.9) {
        // Very hot: UV/blue-white
        color = vec3(0.5, 0.6, 1.0);
    } else if (t > 0.7) {
        // Hot: blue-white
        color = vec3(0.7, 0.8, 1.0);
    } else if (t > 0.5) {
        // Warm: white
        color = vec3(1.0, 0.95, 0.85);
    } else if (t > 0.3) {
        // Yellow
        color = vec3(1.0, 0.85, 0.6);
    } else {
        // Cool: orange-red
        color = vec3(1.0, 0.6, 0.3);
    }
    
    return color;
}

vec3 diskEmission(float r, float phi, float height, float diskTime) {
    // Shakura-Sunyaev temperature profile
    float temp = pow(DISK_INNER / r, 0.75);
    
    // Vertical temperature gradient
    float H = diskThickness(r, uSpinParameter);
    float verticalFactor = exp(-0.5 * (height / H) * (height / H));
    temp *= sqrt(verticalFactor);
    
    // Get blackbody color
    vec3 color = planckSpectrum(temp);
    
    // Base emission (modified blackbody)
    float intensity = pow(DISK_INNER / r, 3.0) * verticalFactor;
    
    // Add MRI turbulence (magneto-rotational instability)
    float turbulence = 0.15 * sin(diskTime * 0.5 + phi * 12.0 + r * 0.8);
    turbulence += 0.08 * sin(diskTime * 0.3 - phi * 8.0 + r * 1.2);
    intensity *= (1.0 + turbulence);
    
    // Spiral density waves
    float spiral = 0.2 * sin(phi * 2.0 - diskTime * 0.2 + log(r) * 3.0);
    intensity *= (1.0 + spiral);
    
    // Hot spots (magnetic reconnection events)
    float hotspot = smoothstep(0.98, 1.0, 
        sin(diskTime * 0.4 + phi * 3.0) * sin(diskTime * 0.3 + r * 0.5));
    intensity += hotspot * 2.0;
    
    return color * intensity;
}

// Enhanced redshift with proper 4-velocity treatment
float redshiftFactor(vec4 pos, vec4 vel, float a, float diskOmega) {
    float r = pos.y;
    float theta = pos.z;
    
    float gtt, gtphi, grr, gthth, gphiphi;
    float gtt_inv, gphiphi_inv, gtphi_inv;
    computeFullMetric(r, theta, a, gtt, gtphi, grr, gthth, gphiphi, 
                     gtt_inv, gphiphi_inv, gtphi_inv);
    
    // Keplerian angular velocity with frame dragging
    float omega_K = M / (r * sqrt(r)) / (1.0 + a * M / (r * sqrt(r)));
    omega_K *= diskOmega;
    
    // Disk 4-velocity
    float norm_factor = sqrt(-gtt - 2.0 * omega_K * gtphi - omega_K * omega_K * gphiphi);
    float ut_disk = 1.0 / norm_factor;
    float uphi_disk = omega_K * ut_disk;
    
    // Photon energy at emission
    float E_emit = -(gtt * vel.x * ut_disk + gtphi * (vel.x * uphi_disk + vel.w * ut_disk) 
                     + gphiphi * vel.w * uphi_disk);
    
    // Photon energy at infinity (conserved)
    float E_inf = -vel.x;
    
    float g = E_inf / abs(E_emit);
    
    return clamp(g, 0.05, 10.0);
}

// ===================================================================
// ENHANCED STARFIELD
// ===================================================================

vec3 advancedStarfield(vec3 dir) {
    vec3 color = vec3(0.0);
    
    // Bright stars
    float h1 = fract(sin(dot(dir.xy, vec2(12.9898, 78.233))) * 43758.5453);
    if (h1 > 0.9985) {
        float brightness = (h1 - 0.9985) / 0.0015;
        float temp = fract(h1 * 7.123);
        vec3 starColor;
        if (temp > 0.7) starColor = vec3(0.6, 0.7, 1.0);      // Blue star
        else if (temp > 0.4) starColor = vec3(1.0, 0.95, 0.9); // White star
        else starColor = vec3(1.0, 0.7, 0.5);                   // Red star
        color = starColor * brightness;
    }
    
    // Dim stars
    float h2 = fract(sin(dot(dir.yz, vec2(93.9898, 67.233))) * 23758.5453);
    if (h2 > 0.997) {
        float brightness = (h2 - 0.997) / 0.003 * 0.4;
        color += vec3(brightness * 0.9, brightness * 0.95, brightness);
    }
    
    // Milky Way structure
    float galactic_plane = abs(dir.y);
    float galaxy_haze = pow(max(0.0, 1.0 - galactic_plane * 2.0), 4.0) * 0.15;
    float galaxy_variation = sin(atan(dir.z, dir.x) * 8.0) * 0.5 + 0.5;
    galaxy_haze *= 0.5 + 0.5 * galaxy_variation;
    color += vec3(galaxy_haze * 0.6, galaxy_haze * 0.7, galaxy_haze * 0.9);
    
    // Distant galaxies
    float h3 = fract(sin(dot(dir.xz, vec2(41.123, 89.456))) * 33758.5453);
    if (h3 > 0.9995) {
        float size = (h3 - 0.9995) / 0.0005;
        color += vec3(size * 0.3, size * 0.35, size * 0.4);
    }
    
    // Nebula glow
    float nebula = smoothstep(0.3, 0.8, 
        sin(dir.x * 5.0 + dir.y * 3.0) * sin(dir.z * 4.0 + dir.y * 6.0)) * 0.1;
    color += vec3(nebula * 0.8, nebula * 0.4, nebula * 0.6);
    
    // Base dark sky
    color += vec3(0.005, 0.005, 0.01);
    
    return color;
}

// ===================================================================
// MAIN RAY TRACING WITH MULTIPLE BOUNCES
// ===================================================================

vec3 traceRay(vec3 rayOrigin, vec3 rayDir, float a, int maxBounces, out float brightness) {
    float r0 = length(rayOrigin);
    float theta0 = acos(clamp(rayOrigin.y / r0, -1.0, 1.0));
    float phi0 = atan(rayOrigin.z, rayOrigin.x);
    
    RayState ray;
    ray.pos = vec4(0.0, r0, theta0, phi0);
    
    // Enhanced initial momentum
    vec3 e_r = rayOrigin / r0;
    vec3 e_theta_unnorm = vec3(
        -e_r.y * e_r.x,
        1.0 - e_r.y * e_r.y,
        -e_r.y * e_r.z
    );
    vec3 e_theta = normalize(e_theta_unnorm);
    vec3 e_phi = cross(e_r, e_theta);
    
    float dr0 = dot(rayDir, e_r);
    float dtheta0 = dot(rayDir, e_theta) / r0;
    float dphi0 = dot(rayDir, e_phi) / (r0 * sin(theta0));
    
    // Initialize with conserved quantities
    ray.E = 1.0;
    ray.Lz = r0 * sin(theta0) * dphi0;
    ray.Q = 0.0; // Will be computed from motion
    
    float gtt, gtphi, grr, gthth, gphiphi;
    float gtt_inv, gphiphi_inv, gtphi_inv;
    computeFullMetric(r0, theta0, a, gtt, gtphi, grr, gthth, gphiphi,
                     gtt_inv, gphiphi_inv, gtphi_inv);
    
    ray.vel.x = -ray.E;
    ray.vel.y = dr0 * 0.1;
    ray.vel.z = dtheta0 * 0.1;
    ray.vel.w = dphi0 * 0.01;
    
    float dlambda = 0.05;
    float r_horizon = eventHorizon(a);
    
    vec3 accumulatedColor = vec3(0.0);
    float accumulatedBrightness = 0.0;
    int bounceCount = 0;
    
    for (int step = 0; step < MAX_STEPS; step++) {
        float r = ray.pos.y;
        float theta = ray.pos.z;
        
        // Adaptive step with error control
        float curvature = 1.5 * M / r;
        float targetError = 1e-4;
        dlambda = clamp(0.01 / (1.0 + curvature * 10.0), 0.005, 0.1);
        
        float error;
        rk5Step(ray, a, dlambda, error);
        
        // Adjust step size based on error
        if (error > targetError && dlambda > 0.01) {
            dlambda *= 0.5;
        } else if (error < targetError * 0.1 && dlambda < 0.05) {
            dlambda *= 1.5;
        }
        
        // Check horizon
        if (r < r_horizon * 1.01) {
            accumulatedColor = vec3(0.0);
            break;
        }
        
        // Escape to infinity
        if (r > 100.0) {
            vec3 finalDir = normalize(vec3(
                sin(theta) * cos(ray.pos.w),
                cos(theta),
                sin(theta) * sin(ray.pos.w)
            ));
            accumulatedColor += advancedStarfield(finalDir);
            break;
        }
        
        // Disk intersection
        float diskR, diskH;
        if (intersectDisk(ray.pos, diskR, diskH)) {
            float g = redshiftFactor(ray.pos, ray.vel, a, 1.0);
            vec3 emission = diskEmission(diskR, ray.pos.w, diskH, uTime);
            
            // Doppler beaming
            emission *= pow(g, 3.0);
            
            accumulatedColor += emission;
            accumulatedBrightness = max(accumulatedBrightness, length(emission));
            
            // Multiple bounces for self-lensing
            bounceCount++;
            if (bounceCount >= maxBounces) break;
            
            // Continue ray (simplified reflection)
            ray.vel.z = -ray.vel.z * 0.3;
        }
    }
    
    brightness = accumulatedBrightness;
    return accumulatedColor;
}

// ===================================================================
// POST-PROCESSING
// ===================================================================

vec3 acesToneMapping(vec3 color) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
}

vec3 uncharted2Tonemap(vec3 x) {
    float A = 0.15, B = 0.50, C = 0.10, D = 0.20, E = 0.02, F = 0.30;
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 filmicTonemap(vec3 color) {
    vec3 x = max(vec3(0.0), color - 0.004);
    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= int(uResolution.x) || pixelCoord.y >= int(uResolution.y)) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoord) + 0.5) / uResolution;
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.x *= uResolution.x / uResolution.y;
    
    // Camera setup
    float orbitAngle = uTime * 0.1;
    float inclinationRad = radians(uInclination);
    
    vec3 cameraPos = vec3(
        uCameraDistance * sin(inclinationRad) * cos(orbitAngle),
        uCameraDistance * cos(inclinationRad),
        uCameraDistance * sin(inclinationRad) * sin(orbitAngle)
    );
    
    vec3 cameraTarget = vec3(0.0);
    vec3 cameraUp = vec3(0.0, 1.0, 0.0);
    
    vec3 forward = normalize(cameraTarget - cameraPos);
    vec3 right = normalize(cross(forward, cameraUp));
    vec3 up = cross(right, forward);
    
    float fov = 45.0;
    float fovScale = tan(radians(fov) / 2.0);
    vec3 rayDir = normalize(forward + right * ndc.x * fovScale + up * ndc.y * fovScale);
    
    // Trace with multiple bounces
    float brightness;
    vec3 color = traceRay(cameraPos, rayDir, uSpinParameter, MAX_BOUNCES, brightness);
    
    // Apply exposure
    color *= uExposure;
    
    // Store bright pixels for bloom
    if (brightness > BLOOM_THRESHOLD) {
        imageStore(bloomBuffer, pixelCoord, vec4(color * (brightness - BLOOM_THRESHOLD), 1.0));
    }
    
    // Tone mapping
    color = acesToneMapping(color);
    
    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));
    
    // Subtle vignette
    float vignette = smoothstep(0.8, 0.3, length(ndc));
    color *= 0.4 + 0.6 * vignette;
    
    imageStore(outputImage, pixelCoord, vec4(color, 1.0));
}
